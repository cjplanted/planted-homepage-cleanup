---
/**
 * LocatorResultsV3 - Main container for the cream-themed V3 locator
 * Displays restaurant results with filter bar, cards grid, and detail panel
 */
import VenueCardV3, { type VenueV3 } from './VenueCardV3.astro';
import VenueDetailPanelV3 from './VenueDetailPanelV3.astro';
import IconsV3 from './icons/IconsV3.astro';
import './locator.css';

export interface Props {
  locale?: string;
  country?: string;
  city?: string;
  postalCode?: string;
  venues?: VenueV3[];
  translations?: {
    headerTitle: string;
    resultsNearYou: string;
    dishesFound: string;
    loadMore: string;
    viewAllDishes: string;
    dishes: string;
    vegan: string;
    all: string;
    under500m: string;
    under1km: string;
    topRated: string;
    products: string;
    dishesWithPlanted: string;
    orderFrom: string;
    close: string;
    noResults: string;
    noResultsMessage: string;
  };
}

const {
  locale = 'de',
  country = 'Schweiz',
  city = 'Zürich',
  postalCode = '8001',
  venues = [],
  translations = {
    headerTitle: '{count} Restaurants mit planted.',
    resultsNearYou: 'Restaurants in deiner Nähe',
    dishesFound: '{count} Gerichte gefunden',
    loadMore: 'Mehr laden',
    viewAllDishes: 'Alle Gerichte ansehen',
    dishes: 'Gerichte',
    vegan: 'Vegan',
    all: 'Alle',
    under500m: '<500m',
    under1km: '<1km',
    topRated: 'Top Rated',
    products: 'planted. Produkte',
    dishesWithPlanted: 'Gerichte mit planted.',
    orderFrom: 'Bestellen bei',
    close: 'Schliessen',
    noResults: 'Keine Ergebnisse',
    noResultsMessage: 'Keine Restaurants in deiner Nähe gefunden.',
  }
} = Astro.props;

// Calculate total dishes
const totalDishes = venues.reduce((sum, v) => sum + v.dishes.length, 0);

// Get unique products for filter chips
const allProducts = [...new Set(venues.flatMap(v => v.products))].slice(0, 3);

// Format header title
const headerTitle = translations.headerTitle.replace('{count}', String(venues.length));
const dishesFoundText = translations.dishesFound.replace('{count}', String(totalDishes));
---

<div class="locator-v3" id="locatorV3">
  <!-- Header -->
  <header class="v3-header">
    <div class="v3-header-inner">
      <button class="v3-back-btn" id="v3BackBtn" type="button" aria-label="Zurück">
        <IconsV3 name="arrow-left" />
      </button>
      <div class="v3-header-info">
        <div class="v3-header-location">
          <IconsV3 name="location" />
          {country} · {postalCode} {city}
        </div>
        <div class="v3-header-title">{headerTitle}</div>
      </div>
    </div>
  </header>

  <!-- Filters Bar -->
  <div class="v3-filters-bar">
    <div class="v3-filters-inner">
      <button class="v3-filter-chip active" data-filter="all">
        <IconsV3 name="star" />
        {translations.all}
      </button>
      <button class="v3-filter-chip" data-filter="distance-500">
        <IconsV3 name="location" />
        {translations.under500m}
      </button>
      <button class="v3-filter-chip" data-filter="distance-1000">
        <IconsV3 name="location" />
        {translations.under1km}
      </button>
      <button class="v3-filter-chip" data-filter="top-rated">
        <IconsV3 name="star" />
        {translations.topRated}
      </button>
      {allProducts.map((product) => (
        <button class="v3-filter-chip" data-filter={`product-${product}`}>
          {product}
        </button>
      ))}
    </div>
  </div>

  <!-- Main Content -->
  <main class="v3-main-content">
    <div class="v3-results-header">
      <div class="v3-results-title">{translations.resultsNearYou}</div>
      <div class="v3-results-count">{dishesFoundText}</div>
    </div>

    <!-- Card grid - always rendered for client-side population -->
    <div class="v3-card-grid" id="v3CardGrid">
      {venues.map((venue, index) => (
        <VenueCardV3
          venue={venue}
          translations={{
            viewAllDishes: translations.viewAllDishes,
            dishes: translations.dishes,
            vegan: translations.vegan,
          }}
          data-index={index}
          data-initially-hidden={index >= 3 ? "true" : "false"}
        />
      ))}
    </div>

    <!-- Load more button - always rendered for client-side control -->
    <div class="v3-load-more" id="v3LoadMore" style={venues.length <= 3 ? "display: none;" : ""}>
      <button class="v3-load-more-btn" type="button" id="v3LoadMoreBtn">
        {translations.loadMore}
        <span class="v3-load-more-count" id="v3LoadMoreCount">
          (+{Math.max(0, venues.length - 3)} mehr)
        </span>
      </button>
    </div>

    <!-- No results message - shown when no venues found after API call -->
    <div class="v3-no-results" id="v3NoResults" style={venues.length > 0 ? "display: none;" : ""}>
      <div class="v3-no-results-icon">
        <IconsV3 name="restaurant" />
      </div>
      <h3>{translations.noResults}</h3>
      <p>{translations.noResultsMessage}</p>
    </div>
  </main>

  <!-- Detail Panel Overlay -->
  <VenueDetailPanelV3
    translations={{
      products: translations.products,
      dishesWithPlanted: translations.dishesWithPlanted,
      orderFrom: translations.orderFrom,
      vegan: translations.vegan,
      close: translations.close,
    }}
  />
</div>

<script define:vars={{ venues }}>
  // Store venues data globally for detail panel access
  window.__v3Venues = venues;
</script>

<script>
  // Filter and interaction controller with progressive loading
  // NOTE: This controller is only for SSR-rendered venues (static pages)
  // When API loading is active (locator-v3.astro), that script handles everything
  class V3LocatorController {
    private filterChips: NodeListOf<HTMLElement>;
    private cardGrid: HTMLElement | null;
    private loadMoreBtn: HTMLElement | null;
    private loadMoreContainer: HTMLElement | null;
    private loadMoreCount: HTMLElement | null;
    private allVenues: any[];
    private visibleCount: number = 3;
    private batchSize: number = 3;
    private isLoading: boolean = false;
    private disabled: boolean = false;

    constructor() {
      // Always set up back button (needed for all modes)
      const backBtn = document.getElementById('v3BackBtn');
      backBtn?.addEventListener('click', () => this.handleBack());

      // Skip the rest if API loader is active (locator-v3.astro handles card loading)
      if ((window as any).__v3Config) {
        console.log('[V3Controller] Card handling disabled - API loader is active');
        this.disabled = true;
        return;
      }

      this.filterChips = document.querySelectorAll('.v3-filter-chip');
      this.cardGrid = document.getElementById('v3CardGrid');
      this.loadMoreBtn = document.getElementById('v3LoadMoreBtn');
      this.loadMoreContainer = document.getElementById('v3LoadMore');
      this.loadMoreCount = document.getElementById('v3LoadMoreCount');
      this.allVenues = (window as any).__v3Venues || [];

      this.init();
    }

    private init() {
      if (this.disabled) return;

      // Filter chip clicks
      this.filterChips.forEach(chip => {
        chip.addEventListener('click', () => this.handleFilterClick(chip));
      });

      // Note: Back button handler is set up in constructor (works for all modes)

      // Load more button click
      this.loadMoreBtn?.addEventListener('click', () => this.loadMore());

      // Infinite scroll - load more when approaching bottom
      this.setupInfiniteScroll();

      // Update initial count display
      this.updateLoadMoreCount();
    }

    private setupInfiniteScroll() {
      // Only enable infinite scroll after first user scroll
      let hasScrolled = false;
      let scrollTimeout: number;

      const enableInfiniteScroll = () => {
        if (hasScrolled) return;
        hasScrolled = true;

        // Small delay to ensure smooth experience
        scrollTimeout = window.setTimeout(() => {
          const observer = new IntersectionObserver(
            (entries) => {
              entries.forEach((entry) => {
                if (entry.isIntersecting && !this.isLoading) {
                  this.loadMore();
                }
              });
            },
            { rootMargin: '100px' }
          );

          if (this.loadMoreContainer) {
            observer.observe(this.loadMoreContainer);
          }
        }, 300);
      };

      // Listen for scroll to enable infinite scroll
      window.addEventListener('scroll', enableInfiniteScroll, { once: true, passive: true });
    }

    private loadMore() {
      if (this.isLoading || !this.cardGrid) return;

      const hiddenCards = this.cardGrid.querySelectorAll('.v3-venue-card.v3-card-hidden');
      if (hiddenCards.length === 0) {
        // All cards visible, hide the load more button
        if (this.loadMoreContainer) {
          this.loadMoreContainer.style.display = 'none';
        }
        return;
      }

      this.isLoading = true;

      // Reveal next batch of cards with staggered animation
      const cardsToReveal = Array.from(hiddenCards).slice(0, this.batchSize);

      cardsToReveal.forEach((card, index) => {
        setTimeout(() => {
          card.classList.remove('v3-card-hidden');
          card.classList.add('v3-card-revealing');

          // Remove the revealing class after animation completes
          setTimeout(() => {
            card.classList.remove('v3-card-revealing');
          }, 400);
        }, index * 100); // Stagger by 100ms
      });

      this.visibleCount += cardsToReveal.length;

      // Update count and check if more to load
      setTimeout(() => {
        this.updateLoadMoreCount();
        this.isLoading = false;

        // Check if all cards are now visible
        const stillHidden = this.cardGrid?.querySelectorAll('.v3-venue-card.v3-card-hidden');
        if (stillHidden?.length === 0 && this.loadMoreContainer) {
          this.loadMoreContainer.style.display = 'none';
        }
      }, cardsToReveal.length * 100 + 100);
    }

    private updateLoadMoreCount() {
      if (!this.loadMoreCount || !this.cardGrid) return;

      const hiddenCards = this.cardGrid.querySelectorAll('.v3-venue-card.v3-card-hidden');
      const remaining = hiddenCards.length;

      if (remaining > 0) {
        this.loadMoreCount.textContent = `(+${remaining} mehr)`;
      } else {
        this.loadMoreCount.textContent = '';
      }
    }

    private handleFilterClick(chip: HTMLElement) {
      // Update active state
      this.filterChips.forEach(c => c.classList.remove('active'));
      chip.classList.add('active');

      const filter = chip.getAttribute('data-filter');
      this.applyFilter(filter);
    }

    private applyFilter(filter: string | null) {
      if (!this.cardGrid) return;

      const cards = this.cardGrid.querySelectorAll('.v3-venue-card');

      // First, reveal all cards (remove hidden class) so filter can work properly
      cards.forEach(card => {
        card.classList.remove('v3-card-hidden');
      });

      // Hide load more when filtering
      if (this.loadMoreContainer) {
        this.loadMoreContainer.style.display = 'none';
      }

      cards.forEach((card) => {
        const venueId = card.getAttribute('data-venue-id');
        const venue = this.allVenues.find((v: any) => v.id === venueId);

        if (!venue) {
          (card as HTMLElement).style.display = '';
          return;
        }

        let show = true;

        switch (filter) {
          case 'all':
            show = true;
            break;
          case 'distance-500':
            show = (venue.distanceMeters || 0) <= 500;
            break;
          case 'distance-1000':
            show = (venue.distanceMeters || 0) <= 1000;
            break;
          case 'top-rated':
            show = (venue.rating || 0) >= 4.5;
            break;
          default:
            // Product filter
            if (filter?.startsWith('product-')) {
              const product = filter.replace('product-', '');
              show = venue.products.includes(product);
            }
        }

        (card as HTMLElement).style.display = show ? '' : 'none';
      });

      // Re-animate visible cards
      this.reAnimateCards();
    }

    private reAnimateCards() {
      if (!this.cardGrid) return;

      const visibleCards = this.cardGrid.querySelectorAll('.v3-venue-card:not([style*="display: none"])');
      visibleCards.forEach((card, index) => {
        (card as HTMLElement).style.animation = 'none';
        (card as HTMLElement).offsetHeight; // Trigger reflow
        (card as HTMLElement).style.animation = '';
        (card as HTMLElement).style.animationDelay = `${0.05 * (index + 1)}s`;
      });
    }

    private handleBack() {
      // Navigate back to homepage locator section
      // Detect base path dynamically from current URL
      const pathname = window.location.pathname;

      // Find the locale segment (e.g., ch-de, de, at)
      // URL could be: /planted-website/ch-de/locator-v3 or /ch-de/locator-v3
      const localeMatch = pathname.match(/\/([a-z]{2}(?:-[a-z]{2})?)\//i);
      const locale = localeMatch ? localeMatch[1] : 'ch-de';

      // Get base path (everything before the locale)
      const localeIndex = pathname.indexOf(`/${locale}/`);
      const basePath = localeIndex > 0 ? pathname.substring(0, localeIndex) : '';

      // Navigate to homepage with locator anchor
      window.location.href = `${basePath}/${locale}/#locator`;
    }
  }

  // Initialize controller
  document.addEventListener('DOMContentLoaded', () => {
    new V3LocatorController();
  });

  // Also initialize on astro:page-load for client-side navigation
  document.addEventListener('astro:page-load', () => {
    new V3LocatorController();
  });
</script>
