---
/**
 * Locator V3 Results Page
 * Displays restaurant results in cream-themed card layout
 * Fetches real venue data from the Planted API
 */
import Layout from '../../layouts/Layout.astro';
import LocatorResultsV3 from '../../components/locator/LocatorResultsV3.astro';
import { allLocales, type LocaleCode } from '../../i18n/config';
import { getTranslations } from '../../i18n/index';
import type { VenueV3 } from '../../components/locator/VenueCardV3.astro';
// Import postal code JSON directly for client-side use
import postalCodesCH from '../../data/postal-codes-ch.json';
import postalCodesDE from '../../data/postal-codes-de.json';
import postalCodesAT from '../../data/postal-codes-at.json';

// Combine postal codes for client-side lookup
const postalCodesData = {
  ch: postalCodesCH,
  de: postalCodesDE,
  at: postalCodesAT
};

export async function getStaticPaths() {
  return allLocales.map((locale) => ({
    params: { locale },
    props: { locale },
  }));
}

const { locale } = Astro.props as { locale: LocaleCode };
const t = getTranslations(locale);

// Parse URL parameters for location
const searchParams = Astro.url.searchParams;
const zip = searchParams.get('zip') || '';
const lat = searchParams.get('lat') || '';
const lng = searchParams.get('lng') || '';
const countryCode = searchParams.get('country') || 'ch';
const cityParam = searchParams.get('city') || '';

// Map country codes to display names
const countryNames: Record<string, string> = {
  'ch': 'Schweiz',
  'de': 'Deutschland',
  'at': 'Österreich',
  'uk': 'United Kingdom',
  'nl': 'Nederland',
  'fr': 'France',
  'it': 'Italia',
  'es': 'España'
};

const countryName = countryNames[countryCode] || countryCode.toUpperCase();

// API configuration
const API_BASE_URL = 'https://europe-west6-get-planted-db.cloudfunctions.net';

// V3-specific translations
const v3Translations = {
  headerTitle: '{count} Restaurants mit planted.',
  resultsNearYou: 'Restaurants in deiner Nähe',
  dishesFound: '{count} Gerichte gefunden',
  loadMore: 'Mehr laden',
  viewAllDishes: 'Alle Gerichte ansehen',
  dishes: 'Gerichte',
  vegan: 'Vegan',
  all: 'Alle',
  under500m: '<500m',
  under1km: '<1km',
  topRated: 'Top Rated',
  products: 'planted. Produkte',
  dishesWithPlanted: 'Gerichte mit planted.',
  orderFrom: 'Bestellen bei',
  close: 'Schliessen',
  noResults: 'Keine Ergebnisse',
  noResultsMessage: 'Keine Restaurants in deiner Nähe gefunden.',
  loading: 'Restaurants werden geladen...',
  errorLoading: 'Fehler beim Laden der Restaurants',
};

// Pass empty venues - will be populated client-side from API
const initialVenues: VenueV3[] = [];
---

<Layout title="Restaurants - planted." locale={locale}>
  <LocatorResultsV3
    locale={locale}
    country={countryName}
    city={cityParam}
    postalCode={zip}
    venues={initialVenues}
    translations={v3Translations}
  />
</Layout>

<style is:global>
  /* Override Layout default to work with cream theme */
  body {
    background: #FDF9F4;
  }

  /* Adjust V3 locator to account for navbar */
  .locator-v3 {
    padding-top: 80px; /* Space for fixed navbar */
  }

  /* Adjust header position for fixed navbar */
  .v3-header {
    top: 80px; /* Below navbar */
  }

  .v3-filters-bar {
    top: 156px; /* Below navbar + v3-header (80 + 76) */
  }

  /* Loading state */
  .v3-loading {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 4rem 2rem;
    text-align: center;
    color: #666;
  }

  .v3-loading-spinner {
    width: 48px;
    height: 48px;
    border: 3px solid #E8E0D5;
    border-top-color: #2D5A27;
    border-radius: 50%;
    animation: v3Spin 1s linear infinite;
    margin-bottom: 1rem;
  }

  @keyframes v3Spin {
    to { transform: rotate(360deg); }
  }

  .v3-error {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 4rem 2rem;
    text-align: center;
    color: #c00;
  }

  .v3-error-icon {
    font-size: 3rem;
    margin-bottom: 1rem;
  }

  /* Skeleton loading styles */
  .v3-skeleton-card {
    pointer-events: none;
  }

  .v3-skeleton-text,
  .v3-skeleton-icon,
  .v3-skeleton-tag {
    background: linear-gradient(90deg, #E8E0D5 25%, #F0EBE3 50%, #E8E0D5 75%);
    background-size: 200% 100%;
    animation: v3SkeletonPulse 1.5s ease-in-out infinite;
    border-radius: 4px;
  }

  .v3-skeleton-icon {
    width: 40px;
    height: 40px;
    border-radius: 8px;
  }

  .v3-skeleton-title {
    height: 20px;
    width: 60%;
    margin-bottom: 8px;
  }

  .v3-skeleton-meta {
    height: 16px;
    width: 40%;
  }

  .v3-skeleton-distance {
    height: 16px;
    width: 50px;
  }

  .v3-skeleton-tag {
    display: inline-block;
    height: 24px;
    width: 80px;
    margin-right: 8px;
  }

  .v3-skeleton-dish {
    height: 16px;
    width: 100%;
    margin-bottom: 8px;
  }

  .v3-skeleton-button {
    height: 20px;
    width: 120px;
  }

  .v3-skeleton-count {
    height: 16px;
    width: 60px;
  }

  @keyframes v3SkeletonPulse {
    0% {
      background-position: 200% 0;
    }
    100% {
      background-position: -200% 0;
    }
  }
</style>

<script define:vars={{ API_BASE_URL, v3Translations }}>
  // Store config for client-side access - read URL params at runtime
  const urlParams = new URLSearchParams(window.location.search);
  window.__v3Config = {
    lat: urlParams.get('lat') || '',
    lng: urlParams.get('lng') || '',
    zip: urlParams.get('zip') || '',
    countryCode: urlParams.get('country') || 'ch',
    apiBaseUrl: API_BASE_URL,
    translations: v3Translations
  };
  console.log('[V3] Config from URL:', window.__v3Config);
</script>

<script define:vars={{ postalCodesData }}>
  /**
   * V3 API Loader - Fetches real venue data from the Planted API
   */

  // Client-side postal code lookup using data passed from server
  // NOTE: No TypeScript here - this runs as plain JavaScript in the browser
  function lookupPostalCode(zip, country) {
    const countryData = postalCodesData[country.toLowerCase()];
    if (!countryData) return null;
    const data = countryData[zip];
    if (!data) return null;
    return { lat: data.lat, lng: data.lng, city: data.city };
  }

  // NOTE: This is plain JavaScript (define:vars scripts don't process TypeScript)
  // API types are described in comments for documentation:
  // ApiPrice: { amount: number, currency: string }
  // ApiDish: { id, name, description?, price, image_url?, dietary_tags?, planted_products, cuisine_type? }
  // ApiVenue: { id, name, type, address: {street, city, postal_code, country}, location, delivery_platforms?, distance_km }
  // NearbyResult: { venue, dishes, is_open, next_open, today_hours }
  // NearbyResponse: { results, total, has_more }
  // VenueV3: { id, name, location, category, distance, distanceMeters?, products, dishes, iconType?, heroImage?, deliveryPartners? }

  // Platform icon mapping
  const platformIcons = {
    'uber_eats': 'uber-eats',
    'uber-eats': 'uber-eats',
    'ubereats': 'uber-eats',
    'just_eat': 'just-eat',
    'just-eat': 'just-eat',
    'justeat': 'just-eat',
    'lieferando': 'lieferando',
    'wolt': 'wolt',
    'doordash': 'doordash',
    'deliveroo': 'deliveroo',
    'eat_ch': 'eat-ch',
    'eat-ch': 'eat-ch',
    'eatch': 'eat-ch',
  };

  // Map API response to VenueV3 format
  function mapToVenueV3(result) {
    const venue = result.venue;
    const dishes = result.dishes || [];

    // Get unique planted products from dishes
    const products = [...new Set(
      dishes
        .flatMap(d => d.planted_products || [])
        .filter(Boolean)
    )].slice(0, 4);

    // Format distance
    const distanceKm = venue.distance_km || 0;
    const distanceStr = distanceKm < 1
      ? `${Math.round(distanceKm * 1000)}m`
      : `${distanceKm.toFixed(1)}km`;

    // Determine icon type based on venue type and dish cuisines
    const cuisines = dishes.map(d => d.cuisine_type).filter(Boolean);
    let iconType = 'restaurant';
    if (cuisines.some(c => /burger/i.test(c))) iconType = 'burger';
    else if (cuisines.some(c => /bowl|poke|asian/i.test(c))) iconType = 'bowl';
    else if (cuisines.some(c => /kebab|döner|turkish/i.test(c))) iconType = 'kebab';

    // Map delivery partners (only active ones, or all if active field is missing)
    const deliveryPartners = (venue.delivery_platforms || [])
      .filter(p => p.active !== false)
      .map(p => ({
        name: p.platform.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
        url: p.url,
        icon: platformIcons[p.platform.toLowerCase()] || 'website'
      }));

    // Find hero image from dishes
    const heroImage = dishes.find(d => d.image_url)?.image_url;

    // Get first cuisine type from dishes
    const category = cuisines[0] || (venue.type === 'delivery_kitchen' ? 'Lieferküche' : 'Restaurant');

    return {
      id: venue.id,
      name: venue.name,
      logoInitials: venue.name.split(/[\s&-]+/).map(w => w[0]).join('').toUpperCase().slice(0, 2),
      chain_logo: venue.chain_logo,
      location: venue.address?.city || '',
      category,
      distance: distanceStr,
      distanceMeters: Math.round(distanceKm * 1000),
      products: products.length > 0 ? products : ['planted.chicken'],
      dishes: dishes.map(d => ({
        name: d.name,
        price: d.price ? `${d.price.currency} ${d.price.amount.toFixed(2)}` : '',
        description: d.description,
        ingredients: d.description || d.name,
        image: d.image_url,
        isVegan: d.dietary_tags?.includes('vegan'),
        plantedProduct: d.planted_products?.[0]
      })),
      iconType,
      heroImage,
      deliveryPartners
    };
  }

  // Render a venue card HTML
  function renderVenueCard(venue, index, translations) {
    const previewDishes = venue.dishes.slice(0, 2);
    const isHidden = index >= 3;

    return `
      <article class="v3-venue-card ${isHidden ? 'v3-card-hidden' : ''}" data-venue-id="${venue.id}" data-index="${index}">
        <div class="v3-card-header">
          <div class="v3-venue-icon">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M3 2v7c0 1.1.9 2 2 2h4a2 2 0 0 0 2-2V2"/>
              <path d="M7 2v20"/>
              <path d="M21 15V2v0a5 5 0 0 0-5 5v6c0 1.1.9 2 2 2h3zm0 0v7"/>
            </svg>
          </div>
          <div class="v3-venue-info">
            <h3 class="v3-venue-name">${venue.name}</h3>
            <div class="v3-venue-meta">
              <span>${venue.location}</span>
              <span>${venue.category}</span>
            </div>
          </div>
          <span class="v3-venue-distance">${venue.distance}</span>
        </div>

        <div class="v3-product-tags">
          ${venue.products.map(p => `<span class="v3-product-tag">${p}</span>`).join('')}
        </div>

        <div class="v3-dishes-list">
          ${previewDishes.map(dish => `
            <div class="v3-dish-item">
              <span class="v3-dish-name">
                ${dish.name}
                ${dish.isVegan ? `<span class="v3-dish-badge">${translations.vegan}</span>` : ''}
              </span>
              <span class="v3-dish-price">${dish.price}</span>
            </div>
          `).join('')}
        </div>

        <footer class="v3-card-footer">
          <button class="v3-view-details-btn" type="button">
            ${translations.viewAllDishes}
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14M12 5l7 7-7 7"/></svg>
          </button>
          <span class="v3-dish-count">${venue.dishes.length} ${translations.dishes}</span>
        </footer>
      </article>
    `;
  }

  // Geocode ZIP code using local database first, with Nominatim API as fallback
  async function geocodeZip(zip, countryCode) {
    // FIRST: Check local postal code database (fast, no API call)
    const localData = lookupPostalCode(zip, countryCode);
    if (localData) {
      console.log('[V3] Found ZIP in local database:', zip, localData);
      return { lat: localData.lat, lng: localData.lng };
    }

    // FALLBACK: Only use Nominatim if not in local DB (rare, for edge cases)
    console.log('[V3] ZIP not in local DB, falling back to Nominatim:', zip);

    // Country code to name mapping for Nominatim
    const countryNames = {
      'ch': 'Switzerland',
      'de': 'Germany',
      'at': 'Austria',
      'uk': 'United Kingdom',
      'nl': 'Netherlands',
      'fr': 'France',
      'it': 'Italy',
      'es': 'Spain'
    };
    const countryName = countryNames[countryCode] || countryCode;

    try {
      const url = `https://nominatim.openstreetmap.org/search?postalcode=${encodeURIComponent(zip)}&country=${encodeURIComponent(countryName)}&format=json&limit=1`;
      const response = await fetch(url, { headers: { 'User-Agent': 'PlantedWebsite/1.0' } });
      if (!response.ok) return null;
      const data = await response.json();
      if (data.length === 0) return null;
      return { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon) };
    } catch {
      return null;
    }
  }

  // Show skeleton loading immediately
  function showSkeletonLoading() {
    const cardGrid = document.getElementById('v3CardGrid');
    const mainContent = document.querySelector('.v3-main-content');

    if (!mainContent || !cardGrid) return;

    // Hide existing grid
    cardGrid.style.display = 'none';

    // Create skeleton cards
    const skeletonHtml = `
      <div class="v3-card-grid v3-skeleton-grid" id="v3SkeletonGrid">
        ${Array.from({ length: 3 }).map(() => `
          <div class="v3-venue-card v3-skeleton-card">
            <div class="v3-card-header">
              <div class="v3-venue-icon v3-skeleton-icon"></div>
              <div class="v3-venue-info" style="flex: 1;">
                <div class="v3-skeleton-text v3-skeleton-title"></div>
                <div class="v3-skeleton-text v3-skeleton-meta"></div>
              </div>
              <div class="v3-skeleton-text v3-skeleton-distance"></div>
            </div>
            <div class="v3-product-tags">
              <span class="v3-skeleton-tag"></span>
              <span class="v3-skeleton-tag"></span>
            </div>
            <div class="v3-dishes-list">
              <div class="v3-skeleton-text v3-skeleton-dish"></div>
              <div class="v3-skeleton-text v3-skeleton-dish"></div>
            </div>
            <div class="v3-card-footer">
              <div class="v3-skeleton-text v3-skeleton-button"></div>
              <div class="v3-skeleton-text v3-skeleton-count"></div>
            </div>
          </div>
        `).join('')}
      </div>
    `;

    // Insert skeleton before the actual grid
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = skeletonHtml;
    if (tempDiv.firstElementChild) {
      mainContent.insertBefore(tempDiv.firstElementChild, cardGrid);
    }
  }

  // Remove skeleton loading
  function removeSkeletonLoading() {
    const skeletonGrid = document.getElementById('v3SkeletonGrid');
    if (skeletonGrid) skeletonGrid.remove();

    const cardGrid = document.getElementById('v3CardGrid');
    if (cardGrid) cardGrid.style.display = '';
  }

  // Main loader function
  async function loadVenues() {
    const config = window.__v3Config;
    if (!config) return;

    const cardGrid = document.getElementById('v3CardGrid');
    const mainContent = document.querySelector('.v3-main-content');
    const headerTitle = document.querySelector('.v3-header-title');
    const resultsCount = document.querySelector('.v3-results-count');
    const loadMoreContainer = document.getElementById('v3LoadMore');
    const loadMoreCount = document.getElementById('v3LoadMoreCount');

    // Show skeleton loading immediately
    showSkeletonLoading();

    try {
      // Build API URL - geocode ZIP if coordinates missing
      let { lat, lng, apiBaseUrl, zip, countryCode } = config;

      // T030: Update header location dynamically with correct country from URL params
      const countryDisplayNames = {
        'ch': 'Schweiz',
        'de': 'Deutschland',
        'at': 'Österreich',
        'uk': 'United Kingdom',
        'nl': 'Nederland',
        'fr': 'France',
        'it': 'Italia',
        'es': 'España'
      };
      const countryDisplay = countryDisplayNames[countryCode] || countryCode.toUpperCase();
      const headerLocation = document.querySelector('.v3-header-location');
      if (headerLocation && zip) {
        // Keep the icon, update the text
        headerLocation.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
            <circle cx="12" cy="10" r="3"></circle>
          </svg>
          ${countryDisplay} · ${zip}
        `;
      }

      // If coordinates missing but ZIP present, geocode the ZIP
      if ((!lat || !lng) && zip) {
        console.log('[V3] Missing coordinates, geocoding ZIP:', zip);
        const coords = await geocodeZip(zip, countryCode || 'ch');
        if (coords) {
          lat = String(coords.lat);
          lng = String(coords.lng);
          console.log('[V3] Geocoded to:', lat, lng);
        }
      }

      if (!lat || !lng) {
        throw new Error('Missing coordinates - could not geocode ZIP');
      }

      // T028: Use slim=true for faster locator display (reduced payload ~18KB -> ~6KB)
      // T029: Use 5km radius to match API default and ensure accurate distance filtering
      const apiUrl = `${apiBaseUrl}/nearby?lat=${lat}&lng=${lng}&radius_km=5&type=restaurant&limit=20&slim=true`;
      console.log('[V3] Fetching venues from:', apiUrl);

      const response = await fetch(apiUrl);
      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }

      const data = await response.json();
      console.log('[V3] Received', data.total, 'venues');

      // Map to VenueV3 format
      const venues = data.results.map(mapToVenueV3);

      // Store in state management
      allVenues = venues;
      filteredVenues = [...venues];
      window.__v3Venues = venues;

      // Remove skeleton loading
      removeSkeletonLoading();

      // Update header
      if (headerTitle) {
        headerTitle.textContent = config.translations.headerTitle.replace('{count}', String(venues.length));
      }

      // Update dish count
      const totalDishes = venues.reduce((sum, v) => sum + v.dishes.length, 0);
      if (resultsCount) {
        resultsCount.textContent = config.translations.dishesFound.replace('{count}', String(totalDishes));
      }

      // Render initial batch of cards (uses new state management)
      renderInitialCards();

    } catch (error) {
      console.error('[V3] Error loading venues:', error);

      // Remove skeleton, show error
      removeSkeletonLoading();

      const mainContent = document.querySelector('.v3-main-content');
      if (mainContent) {
        const errorEl = document.createElement('div');
        errorEl.className = 'v3-error';
        errorEl.innerHTML = `
          <div class="v3-error-icon">⚠️</div>
          <p>${config.translations.errorLoading}</p>
          <p style="font-size: 0.875rem; color: #999; margin-top: 0.5rem;">${error.message || error}</p>
        `;
        mainContent.insertBefore(errorEl, mainContent.firstChild?.nextSibling || null);
      }
    }
  }

  // Re-attach click handlers after dynamic render
  function initCardClickHandlers() {
    const cards = document.querySelectorAll('.v3-venue-card');
    cards.forEach(card => {
      card.addEventListener('click', (e) => {
        // Don't trigger on button click (let button handle it)
        if (e.target.closest('.v3-view-details-btn')) return;

        const venueId = card.getAttribute('data-venue-id');
        if (venueId) {
          openDetailPanel(venueId);
        }
      });

      // Also handle button click
      const btn = card.querySelector('.v3-view-details-btn');
      btn?.addEventListener('click', () => {
        const venueId = card.getAttribute('data-venue-id');
        if (venueId) {
          openDetailPanel(venueId);
        }
      });
    });
  }

  // NOTE: Detail panel is fully handled by VenueDetailPanelV3.astro's V3DetailPanel class
  // It listens for card clicks globally and manages the panel display/hide

  // ========================================
  // STATE MANAGEMENT - Single source of truth
  // ========================================
  let allVenues = [];
  let filteredVenues = [];
  let visibleCount = 0;
  const BATCH_SIZE = 3;
  let currentFilter = 'all';
  let isLoading = false;
  let scrollDebounceTimer = null;

  // ========================================
  // LOAD MORE - Proper progressive loading
  // ========================================
  function loadMore() {
    if (isLoading) return;

    const remaining = filteredVenues.length - visibleCount;
    if (remaining <= 0) return;

    isLoading = true;
    const config = window.__v3Config;
    const cardGrid = document.getElementById('v3CardGrid');

    if (!cardGrid) {
      isLoading = false;
      return;
    }

    // Get next batch
    const nextBatch = filteredVenues.slice(visibleCount, visibleCount + BATCH_SIZE);

    // Append cards with staggered animation
    nextBatch.forEach((venue, i) => {
      const cardHtml = renderVenueCard(venue, visibleCount + i, config.translations);
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = cardHtml.trim();
      const card = tempDiv.firstElementChild;

      // Start hidden for animation
      card.style.opacity = '0';
      card.style.transform = 'translateY(20px)';
      card.classList.remove('v3-card-hidden');

      cardGrid.appendChild(card);

      // Animate in with stagger
      setTimeout(() => {
        card.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
        card.style.opacity = '1';
        card.style.transform = 'translateY(0)';
      }, i * 100);

      // Add click handler
      attachCardClickHandler(card);
    });

    visibleCount += nextBatch.length;
    updateLoadMoreButton();

    // Allow more loads after animation
    setTimeout(() => {
      isLoading = false;
    }, nextBatch.length * 100 + 100);
  }

  // ========================================
  // UPDATE LOAD MORE BUTTON
  // ========================================
  function updateLoadMoreButton() {
    const loadMoreContainer = document.getElementById('v3LoadMore');
    const loadMoreCount = document.getElementById('v3LoadMoreCount');
    const loadMoreBtn = document.getElementById('v3LoadMoreBtn');

    if (!loadMoreContainer || !loadMoreCount) return;

    const remaining = filteredVenues.length - visibleCount;

    if (remaining > 0) {
      loadMoreContainer.style.display = '';
      loadMoreCount.textContent = `(+${remaining} mehr)`;
    } else {
      loadMoreContainer.style.display = 'none';
    }
  }

  // ========================================
  // FILTER HANDLING
  // ========================================
  function applyFilter(filter) {
    currentFilter = filter;
    const config = window.__v3Config;

    // Filter venues based on criteria
    switch (filter) {
      case 'all':
        filteredVenues = [...allVenues];
        break;
      case 'distance-500':
        filteredVenues = allVenues.filter(v => (v.distanceMeters || 0) <= 500);
        break;
      case 'distance-1000':
        filteredVenues = allVenues.filter(v => (v.distanceMeters || 0) <= 1000);
        break;
      case 'top-rated':
        // No rating data from API currently, show all
        filteredVenues = [...allVenues];
        break;
      default:
        if (filter.startsWith('product-')) {
          const product = filter.replace('product-', '');
          filteredVenues = allVenues.filter(v => v.products.includes(product));
        } else {
          filteredVenues = [...allVenues];
        }
    }

    // Reset to initial view
    visibleCount = 0;
    renderInitialCards();
  }

  // ========================================
  // RENDER INITIAL CARDS (first 3)
  // ========================================
  function renderInitialCards() {
    const config = window.__v3Config;
    const cardGrid = document.getElementById('v3CardGrid');
    const noResultsEl = document.getElementById('v3NoResults');

    if (!cardGrid || !config) return;

    // Clear existing cards
    cardGrid.innerHTML = '';

    if (filteredVenues.length === 0) {
      cardGrid.style.display = 'none';
      if (noResultsEl) noResultsEl.style.display = '';
      updateLoadMoreButton();
      return;
    }

    cardGrid.style.display = '';
    if (noResultsEl) noResultsEl.style.display = 'none';

    // Render first batch (no hidden class needed)
    const initialBatch = filteredVenues.slice(0, BATCH_SIZE);
    initialBatch.forEach((venue, i) => {
      const cardHtml = renderVenueCard(venue, i, config.translations);
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = cardHtml.trim();
      const card = tempDiv.firstElementChild;
      card.classList.remove('v3-card-hidden');

      // Animation delay for stagger effect
      card.style.animationDelay = `${0.05 * (i + 1)}s`;

      cardGrid.appendChild(card);
      attachCardClickHandler(card);
    });

    visibleCount = initialBatch.length;
    updateLoadMoreButton();
  }

  // ========================================
  // ATTACH CARD CLICK HANDLER
  // ========================================
  // NOTE: Card clicks are handled by VenueDetailPanelV3.astro's global listener
  // No need for individual handlers here - the panel controller handles everything
  function attachCardClickHandler(card) {
    // No-op: VenueDetailPanelV3.astro handles all card clicks globally
  }

  // ========================================
  // INFINITE SCROLL WITH DEBOUNCE
  // ========================================
  function setupInfiniteScroll() {
    let hasUserScrolled = false;

    const handleScroll = () => {
      if (!hasUserScrolled) {
        hasUserScrolled = true;
      }

      // Debounce scroll handling
      if (scrollDebounceTimer) {
        clearTimeout(scrollDebounceTimer);
      }

      scrollDebounceTimer = window.setTimeout(() => {
        const loadMoreContainer = document.getElementById('v3LoadMore');
        if (!loadMoreContainer || loadMoreContainer.style.display === 'none') return;

        const rect = loadMoreContainer.getBoundingClientRect();
        const isNearBottom = rect.top < window.innerHeight + 200;

        if (isNearBottom && !isLoading) {
          loadMore();
        }
      }, 150);
    };

    window.addEventListener('scroll', handleScroll, { passive: true });
  }

  // ========================================
  // SETUP FILTER CHIPS
  // ========================================
  function setupFilterChips() {
    const filterChips = document.querySelectorAll('.v3-filter-chip');

    filterChips.forEach(chip => {
      chip.addEventListener('click', () => {
        // Update active state
        filterChips.forEach(c => c.classList.remove('active'));
        chip.classList.add('active');

        const filter = chip.getAttribute('data-filter') || 'all';
        applyFilter(filter);
      });
    });
  }

  // ========================================
  // SETUP LOAD MORE BUTTON
  // ========================================
  function setupLoadMoreButton() {
    const loadMoreBtn = document.getElementById('v3LoadMoreBtn');
    loadMoreBtn?.addEventListener('click', () => {
      loadMore();
    });
  }

  // ========================================
  // INITIALIZE ON PAGE LOAD
  // ========================================
  let initialized = false;

  function initialize() {
    if (initialized) return;
    initialized = true;

    loadVenues();
    setupFilterChips();
    setupLoadMoreButton();
    setupInfiniteScroll();
  }

  // Handle DOMContentLoaded - but check if DOM is already ready
  // (Astro places define:vars scripts after </body>, so DOMContentLoaded may have already fired)
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initialize);
  } else {
    // DOM is already ready, call initialize immediately
    initialize();
  }

  document.addEventListener('astro:page-load', () => {
    initialized = false;
    initialize();
  });
</script>
