---
import Layout from '../../../layouts/Layout.astro';
import { getCollection } from 'astro:content';
import { allLocales, locales, type LocaleCode } from '../../../i18n/config';
import { getTranslations } from '../../../i18n/index';

export async function getStaticPaths() {
    return allLocales.map((locale) => ({
        params: { locale },
        props: { locale },
    }));
}

const { locale } = Astro.props as { locale: LocaleCode };
const base = import.meta.env.BASE_URL;
const t = getTranslations(locale);
const localeData = locales[locale];

const recipes = await getCollection('recipes');

// Country-specific cuisine preferences for recipe ordering
// Products that are culturally popular/relevant for each country
const cuisinePreferencesByCountry: Record<string, string[]> = {
    'ch': ['schnitzel', 'bratwurst', 'steak', 'chicken', 'pulled', 'kebab', 'duck'],    // Switzerland: schnitzel, sausage, varied
    'de': ['schnitzel', 'bratwurst', 'steak', 'kebab', 'pulled', 'chicken'],             // Germany: schnitzel, bratwurst, döner culture
    'at': ['schnitzel', 'steak', 'bratwurst', 'chicken', 'kebab', 'pulled'],             // Austria: Wiener Schnitzel is king
    'uk': ['chicken', 'pulled', 'steak', 'kebab', 'nuggets', 'crispy-strips'],           // UK: chicken, pulled pork, kebab culture
    'fr': ['duck', 'steak', 'chicken', 'schnitzel', 'pulled', 'kebab'],                  // France: duck (canard), fine cuts
    'it': ['chicken', 'steak', 'schnitzel', 'pulled', 'kebab', 'skewers'],               // Italy: chicken, grilled meats
    'es': ['chicken', 'steak', 'skewers', 'kebab', 'pulled', 'schnitzel'],               // Spain: grilled meats, skewers (pinchos)
    'nl': ['chicken', 'kebab', 'schnitzel', 'pulled', 'steak', 'nuggets', 'crispy-strips'], // Netherlands: chicken, shoarma/kebab, snacks
    'global': ['chicken', 'steak', 'pulled', 'kebab', 'schnitzel', 'bratwurst'],         // International: balanced mix
};

// Get preference order for current locale's country (fallback to global preferences)
const countryCode = localeData.country;
const preferenceOrder = cuisinePreferencesByCountry[countryCode] || cuisinePreferencesByCountry['global'];

// Custom sort function: prioritize by cuisine preference, then by original order
const sortedRecipes = recipes.sort((a, b) => {
    const productA = a.data.product || 'other';
    const productB = b.data.product || 'other';

    const indexA = preferenceOrder.indexOf(productA);
    const indexB = preferenceOrder.indexOf(productB);

    // If both products are in the preference list, sort by preference
    if (indexA !== -1 && indexB !== -1) {
        if (indexA !== indexB) return indexA - indexB;
    }
    // If only one is in preference list, it comes first
    else if (indexA !== -1) return -1;
    else if (indexB !== -1) return 1;

    // For same preference level or unranked products, sort by original order
    return a.data.order - b.data.order;
});

// Get unique products from recipes (for filter buttons)
const productCounts = sortedRecipes.reduce((acc, r) => {
    const product = r.data.product || 'other';
    acc[product] = (acc[product] || 0) + 1;
    return acc;
}, {} as Record<string, number>);

// Product filter configuration - uses translations
const productFilterIds = ['steak', 'chicken', 'pulled', 'kebab', 'schnitzel', 'bratwurst', 'duck', 'skewers', 'crispy-strips', 'nuggets'] as const;
const productFilters = productFilterIds
    .filter(id => productCounts[id] && productCounts[id] > 0)
    .map(id => ({
        id,
        label: (t.recipes.filters as Record<string, string>)?.[id] || `planted.${id}`
    }));
---

<Layout title={`${t.recipes.pageTitle} – Planted`} currentPage="recipes" locale={locale}>
    <!-- Hero Section -->
    <section class="hero">
        <div class="hero-content">
            <h1 class="reveal">{t.recipes.pageTitle}</h1>
            <p class="reveal reveal-delay-1">{t.recipes.pageSubtitle}</p>
        </div>
    </section>

    <!-- Filter Bar -->
    <div class="filter-bar">
        <div class="filter-scroll">
            <ul class="filter-list">
                <li>
                    <button class="filter-btn active" data-filter="all">
                        {t.recipes.filterAll}
                    </button>
                </li>
                {productFilters.map((product) => (
                    <li>
                        <button class="filter-btn" data-filter={product.id}>
                            {product.label}
                        </button>
                    </li>
                ))}
            </ul>
        </div>
    </div>

    <!-- Recipes Grid -->
    <section class="recipes">
        <div class="recipes-inner">
            <div class="recipes-grid" id="recipesGrid">
                {sortedRecipes.map((recipe, index) => (
                    <a href={`${base}/${locale}/recipes/${recipe.data.slug}`}
                       class="recipe-card"
                       data-product={recipe.data.product || 'other'}
                       style={`--delay: ${Math.min(index * 0.02, 0.3)}s`}>
                        <div class="recipe-image">
                            <img src={recipe.data.image} alt={recipe.data.title} loading="lazy">
                            <div class="recipe-badge">{t.recipes.difficulty[recipe.data.difficulty.toLowerCase() as 'easy' | 'medium' | 'hard'] || recipe.data.difficulty}</div>
                        </div>
                        <div class="recipe-info">
                            <h2 class="recipe-title">{recipe.data.title}</h2>
                            <div class="recipe-meta-grid">
                                {recipe.data.servings && (
                                    <div class="meta-item">
                                        <span class="meta-label">{t.recipes.servings}</span>
                                        <span class="meta-value">{recipe.data.servings}</span>
                                    </div>
                                )}
                                <div class="meta-item">
                                    <span class="meta-label">{t.recipes.duration || 'Time'}</span>
                                    <span class="meta-value">{recipe.data.cookTime} {t.recipes.time}</span>
                                </div>
                                <div class="meta-item">
                                    <span class="meta-label">{t.recipes.level || 'Level'}</span>
                                    <span class="meta-value">{t.recipes.difficulty[recipe.data.difficulty.toLowerCase() as 'easy' | 'medium' | 'hard'] || recipe.data.difficulty}</span>
                                </div>
                            </div>
                        </div>
                    </a>
                ))}
            </div>

            <!-- No results message -->
            <div class="no-results" id="noResults">
                <p>Keine Rezepte gefunden</p>
            </div>
        </div>
    </section>

    <!-- CTA Section -->
    <section class="cta">
        <div class="cta-content">
            <h2 class="reveal">{t.home.locator.title}</h2>
            <p class="reveal reveal-delay-1">{t.home.locator.subtitle}</p>
            <a href={`${base}/${locale}#locator`} class="btn btn-primary btn-primary--on-green reveal reveal-delay-2">
                {t.home.locator.button}
            </a>
        </div>
    </section>
</Layout>

<style>
    :root {
        --purple: #61269E;
        --green: #6BBF59;
        --cream: #FDF8F3;
        --black: #1A1A1A;
        --healthy: #6BBF59;
    }

    /* Hero */
    .hero {
        background: var(--cream);
        padding: 8rem 1.5rem 3rem;
        text-align: center;
    }

    .hero-content {
        max-width: 700px;
        margin: 0 auto;
    }

    .hero h1 {
        font-size: clamp(2.5rem, 10vw, 5rem);
        color: var(--purple);
        margin-bottom: 1rem;
        line-height: 1;
    }

    .hero p {
        font-size: clamp(1rem, 2.5vw, 1.25rem);
        color: var(--black);
        opacity: 0.7;
        max-width: 600px;
        margin: 0 auto;
        line-height: 1.5;
    }

    /* Filter Bar */
    .filter-bar {
        background: var(--cream);
        padding: 0 0.75rem 2rem;
        overflow: hidden;
    }

    .filter-scroll {
        overflow-x: auto;
        padding-bottom: 0.5rem;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
    }

    .filter-scroll::-webkit-scrollbar {
        display: none;
    }

    .filter-list {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        list-style: none;
        margin: 0;
        padding: 0.5rem 0.75rem;
        justify-content: center;
    }

    .filter-btn {
        display: block;
        font-family: inherit;
        font-size: 0.9rem;
        font-weight: 700;
        padding: 0.6rem 1.25rem;
        border-radius: 100px;
        border: 2px solid rgba(97, 38, 158, 0.2);
        background: white;
        color: var(--purple);
        cursor: pointer;
        white-space: nowrap;
        transition: all 0.25s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .filter-btn:hover {
        border-color: var(--purple);
        transform: translateY(-1px);
    }

    .filter-btn.active {
        background: var(--purple);
        border-color: var(--purple);
        color: white;
    }

    /* Recipes Section */
    .recipes {
        background: var(--cream);
        padding: 3rem 0.75rem 5rem;
        min-height: 50vh;
    }

    .recipes-inner {
        max-width: 1400px;
        margin: 0 auto;
        padding: 0 0.75rem;
    }

    .recipes-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 1.5rem;
    }

    /* Recipe Card - Matches eatplanted.com style */
    .recipe-card {
        background: white;
        border-radius: 1.4rem;
        overflow: hidden;
        text-decoration: none;
        display: flex;
        flex-direction: column;
        transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        animation: cardFadeIn 0.4s ease forwards;
        animation-delay: var(--delay, 0s);
        opacity: 0;
    }

    @keyframes cardFadeIn {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .recipe-card:hover {
        transform: translateY(-6px);
        box-shadow: 0 20px 40px rgba(97, 38, 158, 0.15);
    }

    .recipe-card.filtered-out {
        display: none;
    }

    .recipe-image {
        position: relative;
        aspect-ratio: 1;
        overflow: hidden;
    }

    .recipe-image img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .recipe-card:hover .recipe-image img {
        transform: scale(1.1);
    }

    .recipe-badge {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: var(--green);
        color: var(--black);
        font-size: 0.65rem;
        font-weight: 700;
        text-transform: uppercase;
        padding: 0.35rem 0.7rem;
        border-radius: 100px;
        letter-spacing: 0.02em;
    }

    .recipe-info {
        padding: 1rem;
        display: flex;
        flex-direction: column;
        flex-grow: 1;
        background: white;
    }

    .recipe-title {
        font-family: 'VC Henrietta', serif;
        font-size: 1.1rem;
        font-weight: 700;
        color: var(--purple);
        margin-bottom: 1rem;
        line-height: 1.2;
        flex-grow: 1;
    }

    /* Meta grid - matches eatplanted.com 3-column layout */
    .recipe-meta-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        border-top: 2px solid rgba(97, 38, 158, 0.1);
        padding-top: 0.75rem;
        gap: 0.5rem;
    }

    .meta-item {
        text-align: left;
        padding-right: 0.5rem;
    }

    .meta-item:not(:last-child) {
        border-right: 2px solid rgba(97, 38, 158, 0.1);
    }

    .meta-label {
        display: block;
        font-size: 0.7rem;
        color: var(--black);
        opacity: 0.6;
        margin-bottom: 0.15rem;
    }

    .meta-value {
        display: block;
        font-size: 0.85rem;
        font-weight: 700;
        color: var(--purple);
    }

    /* No results */
    .no-results {
        display: none;
        text-align: center;
        padding: 4rem 2rem;
        color: var(--purple);
        font-size: 1.1rem;
        opacity: 0.7;
    }

    .no-results.visible {
        display: block;
    }

    /* CTA */
    .cta {
        background: var(--green);
        padding: 6rem 1.5rem;
        text-align: center;
    }

    .cta-content {
        max-width: 600px;
        margin: 0 auto;
    }

    .cta h2 {
        font-size: clamp(2rem, 6vw, 3.5rem);
        color: var(--black);
        margin-bottom: 1rem;
    }

    .cta p {
        font-size: 1.1rem;
        color: var(--black);
        opacity: 0.8;
        margin-bottom: 2rem;
    }

    .btn {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 1.1rem 2rem;
        border-radius: 100px;
        font-weight: 700;
        font-size: 1rem;
        text-decoration: none;
        transition: all 0.3s ease;
    }


    /* Animations */
    .reveal {
        opacity: 0;
        transform: translateY(30px);
        transition: opacity 0.6s ease, transform 0.6s ease;
    }

    .reveal.active {
        opacity: 1;
        transform: translateY(0);
    }

    .reveal-delay-1 { transition-delay: 0.1s; }
    .reveal-delay-2 { transition-delay: 0.2s; }

    /* Responsive */
    @media (min-width: 640px) {
        .recipes-grid {
            grid-template-columns: repeat(2, 1fr);
        }

        .filter-list {
            flex-wrap: nowrap;
            justify-content: flex-start;
            width: max-content;
            max-width: 100%;
            margin: 0 auto;
        }
    }

    @media (min-width: 768px) {
        .filter-bar {
            padding: 0 1.5rem 2rem;
        }

        .filter-list {
            justify-content: center;
            flex-wrap: wrap;
        }

        .recipes {
            padding: 3rem 1.5rem 5rem;
        }

        .recipes-inner {
            padding: 0;
        }
    }

    @media (min-width: 900px) {
        .recipes-grid {
            grid-template-columns: repeat(3, 1fr);
        }
    }

    @media (min-width: 1200px) {
        .recipes-grid {
            grid-template-columns: repeat(4, 1fr);
        }
    }

    @media (min-width: 1440px) {
        .hero {
            padding: 10rem 5rem 4rem;
        }

        .filter-bar {
            padding: 0 5rem 2.5rem;
        }

        .recipes {
            padding: 4rem 5rem 6rem;
        }

        .cta {
            padding: 8rem 5rem;
        }
    }
</style>

<script>
    function initRecipeFilters() {
        const filterBtns = document.querySelectorAll('.filter-btn');
        const recipeCards = document.querySelectorAll('.recipe-card');
        const noResults = document.getElementById('noResults');

        filterBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                // Update active button
                filterBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                const filter = (btn as HTMLElement).dataset.filter;
                let visibleCount = 0;

                // Filter recipes with animation
                recipeCards.forEach((card, index) => {
                    const product = (card as HTMLElement).dataset.product;
                    const shouldShow = filter === 'all' || product === filter;

                    if (shouldShow) {
                        card.classList.remove('filtered-out');
                        // Reset animation
                        (card as HTMLElement).style.animationDelay = `${Math.min(visibleCount * 0.03, 0.3)}s`;
                        visibleCount++;
                    } else {
                        card.classList.add('filtered-out');
                    }
                });

                // Show/hide no results message
                if (noResults) {
                    noResults.classList.toggle('visible', visibleCount === 0);
                }
            });
        });

        // Reveal animations for CTA section
        const observerOptions = {
            threshold: 0.2,
            rootMargin: '0px 0px -50px 0px'
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('active');
                }
            });
        }, observerOptions);

        document.querySelectorAll('.reveal').forEach(el => observer.observe(el));
    }

    // Initialize on page load
    initRecipeFilters();

    // Re-initialize on Astro page transitions
    document.addEventListener('astro:page-load', initRecipeFilters);
</script>
